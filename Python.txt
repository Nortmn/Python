Конкатена́ция — операция склеивания объектов линейной структуры, обычно строк.



===================================================================================================================================

int - Это функция, возвращающая целое число в десятичной системе счисления. Пример: 2, 4, 8, -10, -2

float - Это функция, возвращающая число с плавающей запятой. Пример: 2.6, -5.2

str - Это функция, возвращающая строку (неизменяемую последовательность символов)

bool - Это функция, возвращающая булево значение (True или False) для объекта

list - Функция, возвращающая изменяемую упорядоченную коллекцию объектов произвольных типов. Пример: [2, 2.4, “Hello”]

tuple - Функция, возвращающая неизменяемую упорядоченную коллекцию объектов произвольных типов. Кортеж. Пример:(2, 2.4, “Hello”)

dict -Функция, возвращающая неупорядоченную коллекцию произвольных объектов с доступом по ключу. Пример: {“name”: “Вася”, “age”: 10}

При делении всегда получается значение с типом "float"


В Puthon имеется множественное присваивание: a, b = 0, 1'
Если слева от знака «=» в множественном присваивании должны стоять через запятую имена переменных, 
то справа могут стоять произвольные выражения, разделённые запятыми. 
Главное, чтобы слева и справа от знака присваивания было одинаковое число элементов.

===================================================================================================================================

+ : Сложение
- : Вычитание
* : Умножение
/ : Деление
// : Целочисленное деление
% : Остаток от деления
** : Возведение в степень

===================================================================================================================================

> : Больше print(40 > 40) -> False
< : Меньше print(3 < 9) -> True
== : Равно print(10 == 10) -> True
!= : Не равно print(2 != 2) -> False
>= : Больше или равно print(40 >= 1) -> True
<= : Меньше или равно print(3 <= 1) -> False

and : Логическое «И». Возвращает значение «Истина», если оба операнда имеют значение «Истина»
	print(True and True) -> True
	print(True and False) -> False
	print(False and True) -> False
	print(False and False) -> False

or : Логическое «ИЛИ». Возвращает значение «Истина», если хотя бы один из операндов имеет значение «Истина»
	print(True or True) -> True
	print(True or False) -> True
	print(False or True) -> True
	print(False or False) -> False

not : Логическое «НЕ». Изменяет логическое значение операнда на противоположное
	print(not True)  -> False
	print(not False) -> True

in : Оператор проверки принадлежности. Возвращает значение «Истина», если элемент присутствует в последовательности
	(см. Урок 2)
	print(10 in  [10, 20, 30]) -> True

===================================================================================================================================
is : Оператор проверки тождественности. Возвращает значение «Истина», если операнды ссылаются на один объект
	(см. Урок 2)
	x = 3
	y = 3
	print(x is y) -> True

Важная особенность использования оператора is заключается в том, что он не идентичен оператору ==.
== — проверка равенства значений двух объектов.
is — проверка идентичности объектов, то есть проверка того, что переменные указывают на один и тот же объект в памяти.

===================================================================================================================================

Оператор elif переводится как «иначе если». Логическое выражение, стоящее после оператора elif, 
проверяется, только если все вышестоящие условия ложные. То есть в этой схеме может выполниться 
только один блок кода: первый, второй, третий или четвёртый. Если одно из выражений истинно, 
то нижестоящие условия проверяться не будут.

===================================================================================================================================

Оператор continue начинает следующий проход цикла, минуя оставшееся тело цикла.

Оператор break досрочно прерывает цикл.

===================================================================================================================================

.join - функция возвращает строку, которая является конкатенацией строк в последовательности seq. 
	Разделителем между элементами является строка обеспечивающий этот метод.

	s = "-"
	seq = ("a", "b", "c") # Это последовательность строк.
	print (s.join( seq ))
	
	результат: a-b-c

===================================================================================================================================

Взятие по модулю : print(abs(-6)) -> 6

Побитовое И : print(4 & 6) -> 4

Побитовое ИЛИ : print(4 | 6) -> 6

Побитовое исключающее ИЛИ : print(4 ^ 6) -> 2

Битовый сдвиг влево : print(4 << 6) -> 256

Битовый сдвиг вправо : print(4 >> 6) -> 0

===================================================================================================================================

int() - Преобразовать к целому числу в десятичном формате (по умолчанию). 
	Также допускается выбор другой системы счисления с 
	помощью дополнительного параметра (от 2 до 36) ( print(int('10001', 2)) -> 17 )
bin() - Преобразовать к двоичному формату
oct() - Преобразовать к восьмеричному формату
hex() - Преобразовать к шестнадцатеричному формату

===================================================================================================================================

Комплексные (complex)
Под комплексным числом понимается выражение вида a + ib, где a и b — любые действительные числа, i — мнимая единица.
	n_1 = complex(5, 6)
	print(n_1)
	n_2 = complex(7, 8)
	print(n_2)

===================================================================================================================================
СТРОКА

Просмотр последнего элемента строки: my_str[-1]

len(строка) - Возвращает длину строки

.isdigid() - Вернёт True, если в строке хотя бы один символ и все символы строки являются цифрами, иначе — False

строка.split(<разделитель>) - Разбить строку по разделителю

<разделитель>.join(список) - Собрать строку из списка с указанным разделителем

строка.title() - Перевести первую букву каждого слова в верхний регистр, остальные - в нижний

строка.upper() - Преобразовать строку к верхнему регистру

строка.lower() - Преобразовать строку к нижнему регистру

строка.istitle() - Проверить, начинаются ли слова строки с буквы в верхнем регистре

строка.isupper() - Проверить, состоит ли строка из символов в верхнем регистре

строка.islower() - Проверить, состоит ли строка из символов в нижнем регистре

ord(символ) - Получить ASCII-код для символа

chr(код) - Получить символ по ASCII-коду

строка.count(подстрока, [начало], [конец]) - Вернуть количество вхождений подстроки в строку

строка.capitalize() - Перевести первый символ строки в верхний регистр, остальные - в нижний

строка.startswith(шаблон) - Проверить, начинается ли строка с шаблона

строка.endswith(шаблон) - Проверить, заканчивается ли строка шаблоном

строка.replace(шаблон, замена) - Заменить в строке шаблон на указанную подстроку

строка.index(подстрока, [начало], [конец]) - Найти подстроку в строке. Получить позицию первого вхождения или получить ValueError

строка.find(подстрока, [начало], [конец]) - Найти подстроку в строке. Получить позицию первого вхождения или получить -1

===================================================================================================================================
СПИСОК


result_list.append(el) - Добавить элемент el в конец списка result_list

result_list.extend(my_list) - Расширить список result_list — 
	добавить в конец элементы списка my_list

result_list.insert(pos, el) - Разместить на позиции pos (индекс элемента списка) элемент el 

result_list.remove(el) - Удалить из списка первый элемент со значением el

result_list.pop(pos) - Удалить элемент с индексом pos

result_list.index(el) - Получить позицию (индекс) первого элемента со значением el

result_list.count(el) - Возвращает количество элементов списка со значением el

result_list.sort([key=функция]) - Выполнить сортировку списка на основе указанной функции

result_list.reverse() - Выполнить реверс списка (развернуть список)

result_list.copy() - Вернуть копию списка

result_list.clear() - Очистить список

===================================================================================================================================
КОРТЕЖ


Кортеж представляет собой аналогичную списку структуру с одним отличием. 
Кортеж — неизменяемая структура. 
Самый простой способ создать кортеж — применить функцию tuple() к итерируемому объекту.

print(tuple('обычная строка'))

Преимущества кортежей:
защищают от неверных действий пользователя. Кортеж — неизменяемый список, защищён от случайных и намеренных изменений;
меньший размер по сравнению со списками.

===================================================================================================================================	
МНОЖЕСТВО

Это контейнер с неповторяющимися элементами, расположенными в случайном порядке. 
Множество, создаваемое с помощью функции set(), представляет собой изменяемый тип данных, 
frozenset() — неизменяемый.

.add(el) - Добавить элемент в множество
.remove(el) - Удалить элемент из множества. Если элемент отсутствует — ошибка KeyError
.discard(el) - Удалить элемент из множества
.pop() - Удалить первый элемент из множества. Множества не упорядочены, поэтому первый элемент множества заранее не определён
.copy() - Создать копию множества
.clear() - Очистить множество

perem_1 = set('abrakadabra')
perem_2 = frozenset('abrakadabra')


===================================================================================================================================	
СЛОВАРЬ

Словарь — неупорядоченный набор произвольных объектов с доступом по ключу. 
Один из вариантов создания словаря — с помощью функции dict().

my_dict = dict(key_1='val_1', key_2='val_2')

my_dict = {"key_1": 500, 2: 400, "key_3": True, 4: None}

.keys() - Возвращает список ключей словаря
.values() - Возвращает список значений
.items() - Возвращает список кортежей (ключ, значение)
.get(key) - Возвращает значение, соответствующее ключу key. Если ключ отсутствует, возвращает значение None
.popitem() - Удаляет элемент словаря и возвращает пару (ключ, значение). Если элементы отсутствуют, возникает исключение KeyError
.setdefault(key) - Возвращает значение, соответствующее ключу. Если ключ отсутствует, создаётся элемент с указанным ключом и значением None
.pop(key) - Удаляет ключ и возвращает значение, соответствующее ключу
.update(new_dict) - Добавляет пары (ключ, значение) в текущий словарь из словаря new_dict. Имеющиеся ключи перезаписываются
.copy() - Возвращает копию словаря
.clear() - Очищает словарь

===================================================================================================================================	
for in для обхода последовательностей



for [переменная-итератор] in [последовательность]:
    [действия, выполняемые для каждой переменной]



for el in "my_string":
    print(el)

===================================================================================================================================	
Понятие тернарного оператора

Понятие тернарного оператора в Python очень близко к понятию условного выражения. Тернарные операторы позволяют вернуть 
некоторый результат в зависимости от истинности или ложности некоторого условия.

Шаблон тернарного оператора:
condition_if_true if condition else condition_if_false

Пример:

is_checked = True
mode = "checked" if is_checked else "not checked"
print(mode)



Есть и другой вариант использования этого подхода (с кортежами):

Шаблон:
(if_check_is_false, if_check_is_true)[param_to_check]

Пример:
checked = True
personality = ("проверено", "не проверено")[checked]
print(personality)

===================================================================================================================================	
Объединение списков без цикла

Явный вариант решения задачи объединения списков разной длины предполагает перебор элементов в цикле. 
Но возможно и более лаконичное решение через функцию sum().

Пример:
my_list = [[10, 20, 30], [40, 50], [60], [70, 80, 90]]
print(sum(my_list, []))

Результат:
[10, 20, 30, 40, 50, 60, 70, 80, 90]

===================================================================================================================================	
Поиск уникальных элементов в списке

Это очень популярный трюк, предполагающий трансформацию списка во множество и поиск уникальных элементов.
Пример:
my_list = [10, 10, 3, 4, 5, 9, 30, 30]
print(list(set(my_list)))

===================================================================================================================================	
Обмен значениями через кортежи

Позволяет выполнять обмен значения без создания дополнительной переменной. Трюк допустим для любого числа переменных.
Пример:
var_1, var_2 = 20, 30
print(var_1, var_2)
var_1, var_2 = var_2, var_1
print(var_1, var_2)

Правая часть выражения может представлять собой любой итерируемый объект. 
Главное, чтобы число элементов в левой и правой частях совпадало.

===================================================================================================================================	
Вывод значения несуществующего ключа в словаре

Если попытаться обратиться к несуществующему ключу словаря, возникнет исключение, чтобы избежать такую ситуацию, 
можно воспользоваться методом get().

my_dict = {'k_1': 20, 'k_2': True, 'k_3': 'text'}
print(my_dict.get('k_4'))

===================================================================================================================================
Поиск самых часто встречающихся элементов списка

Искать самый часто встречающийся элемент можно, используя встроенную функцию max(). Она ищет наибольшее значение не только 
для итерируемого объекта, но и для результатов применения к этому объекту функции. Можно преобразовать список во множество и 
применить метод count для определения количества вхождений элемента в итерируемый объект.

my_list = [10, 20, 20, 20, 30, 50, 70, 30]
print(max(set(my_list), key=my_list.count))

===================================================================================================================================
Вывод с помощью функции print() без перевода строки

По умолчанию функция print() добавляет символ перевода строки, который можно отменить, 
добавив в функцию параметр end со значением пустой строки.

for el in ["ab", "ra", "kada", "bra"]:
    print(el, end='')

===================================================================================================================================
Сортировка словаря по значениям

По умолчанию элементы словаря сортируются по наименованиям ключей. 
Но можно реализовать сортировку по значениям элементов.

Пример:
my_dict = {'python': 1991, 'java': 1995, 'c++': 1983}
print(sorted(my_dict, key=my_dict.get))

Результат:
['c++', 'python', 'java']

===================================================================================================================================
Нумерованные списки

Для реализации нумерованного списка можно воспользоваться функцией enumerate().

for ind, el in enumerate(['ноль', 'один', 'два', 'три']):
    print(ind, el)

for ind, el in enumerate(['один', 'два', 'три'], 1):
    print(ind, el)

===================================================================================================================================
Именные функции

Функция определяется с помощью инструкции def, после которой следует имя функции.
Функция может содержать вложенные функции и возвращать объекты различных типов (списки, словари, функции).

def my_sum(arg_1, arg_2):
    return arg_1 + arg_2


print(my_sum(20, 30))
print(my_sum("abra", "kadabra"))


def ext_func(var_1):
    def int_func(var_2):
        return var_1 + var_2
    return int_func


f_obj = ext_func(200) # f_obj - функция
print(f_obj(300))

===================================================================================================================================
Оператор return

О назначении этого оператора уже говорилось выше. Функции могут принимать данные и возвращать определённый результат 
после их обработки. При этом для выхода из функции и передачи результата в точку вызова применяется оператор return.

В функции можно реализовать несколько операторов return. Но по итогам работы функций может быть выполнен только один.
Это оператор return, его поток выполнения программы достигнет первым.

В Python возможно использование оператора return, возвращающего из функции несколько объектов. 
Достаточно указать их через запятую после оператора return.

def s_calc():
    try:
        r_val = float(input("Укажите радиус: "))
        h_val = float(input("Укажите высоту: "))
    except ValueError:
        return
    s_side = 2 * 3.14 * r_val * h_val
    s_circle = 3.14 * r_val ** 2
    s_full = s_side + 2 * s_circle
    return s_side, s_full


s_side_val, s_full_val = s_calc()
print(f"Площадь боковой пов-ти - {s_side_val}; Полная площадь - {s_full_val}")


Функция s_calc() возвращает два значения, присваиваемые переменным s_side_val и s_full_val. Подобное групповое 
присвоение — важная характеристика Python. Смысл в том, что перечисление значений через запятую формирует объект типа кортеж (tuple). 
Присваивая кортеж сразу набору переменных, его элементы сопоставляются переменным. Происходит своего рода распаковка.
То есть, когда функция возвращает набор объектов, на деле она возвращает объект-кортеж с этими объектами. 
Они упаковываются в кортеж перед возвратом. Если за оператором return следует только одна переменная, её тип сохраняется в исходном состоянии.
===================================================================================================================================
TRY - EXCEPT

Для обработки исключений используется конструкция try - except.
В блоке try мы выполняем инструкцию, которая может породить исключение, а в блоке except мы перехватываем их. 
При этом перехватываются как само исключение, так и его потомки.

>>> try:
...     k = 1 / 0
... except ArithmeticError:
...     k = 0
...
>>> print(k)
0

===================================================================================================================================
PASS

Оператор-заглушка, равноценный отсутствию операции.
В ходе исполнения данного оператора ничего не происходит, поэтому он может использоваться в качестве заглушки в тех местах, 
где это синтаксически необходимо, например: в инструкциях, где тело является обязательным, таких как def, except и пр.

Зачастую pass используется там, где код пока ещё не появился, но планируется. Кроме этого, иногда, его используют при отладке, 
разместив на строчке с ним точку остановки.

===================================================================================================================================
Аргументы функций

Функция может принимать любое количество параметров или не принимать их вообще. Параметры могут быть позиционные и именованные, 
обязательные и необязательные.

# позиционные параметры
def first_func(var_1, var_2, var_3):
    return var_1 + var_2 + var_3

print(first_func(10, 20, 30))


# именованные параметры
def second_func(var_2, var_1, var_3):
    print(f"var_2 - {var_2}; var_1 - {var_1}; var_3 - {var_3}")
    
second_func(var_1=10, var_2=20, var_3=30)


# обязательные параметры
def first_func(var_1, var_2, var_3):
    return var_1 + var_2 + var_3

print(first_func(10, 20, 30))


# var_2 и var_3 - необязательные параметры
def second_func(var_1, var_2=20, var_3=30):
    return var_1 + var_2 + var_3

print(second_func(10))

===================================================================================================================================
Функция может принимать неопределённое число позиционных параметров. 
В этом случае при описании функции используется конструкция *args.


Пример:
def my_func(*args):
    return args

print(my_func(10, "text_1", 20, "text_2"))


Результат:
(10, 'text_1', 20, 'text_2')


Из примера следует, что args представляет собой кортеж, содержащий переданные в функцию аргументы. 
С переменной args можно выполнять те же операции, что и с кортежем.


===================================================================================================================================
Функция может принимать и неопределённое число именованных параметров. Тогда используется конструкция **kwargs.

Пример:
def my_func(**kwargs):
    return kwargs

print(my_func(el_1=10, el_2=20, el_3="text"))


Результат:
{'el_1': 10, 'el_2': 20, 'el_3': 'text'}


Переменная kwargs хранит словарь. С ним можно выполнять привычные для словаря операции.

Важно! 
Операторы * и ** в Python можно использовать и с другими именами переменных. То есть имена args и kwargs необязательны. 
Но помните, что хороший стиль программирования подразумевает использование имён args и kwargs, 
так как сразу становится понятно о назначении таких переменных.

===================================================================================================================================
Используйте общепринятые конструкции *args и **kwargs для захвата позиционных и именованных аргументов.

Конструкцию **kwargs нельзя располагать до *args. Если это сделать — будет выдано сообщение об ошибке.

Остерегайтесь конфликтов между именованными параметрами и **kwargs, в случаях, когда значение планируется передать как **kwarg-аргумент, 
но имя ключа этого значения совпадает с именем именованного параметра.

Оператор *можно использовать не только в объявлениях функций, но и при их вызове.

===================================================================================================================================
lambda

Анонимные функции (lambda)
Это функции, содержащие только одно выражение, но выполняющиеся быстрее именных функций. При этом используется оператор lambda. 
При использовании lambda-функций их необязательно присваивать некоторой переменной, как в случае с именными функциями. 
lambda-функции, в отличие от именных, не требуют оператора return, в остальном — идентичны именным.

Пример:
my_func = lambda p_1, p_2: p_1 + p_2

print(my_func(2, 5))
print(my_func("abra", "kadabra"))

print((lambda p_1, p_2: p_1 + p_2)(2, 5))
print((lambda p_1, p_2: p_1 + p_2)("abra", "kadabra"))

new_func = lambda *args: args
print(new_func(10, 20, 30, 40))

===================================================================================================================================
Функции для операций с символами


ord() - Принимает Unicode-символ и возвращает соответствующий код (целое число)

chr() - Принимает целое число и возвращает Unicode-символ, 
соответствующий переданному числу (коду)

len() - Принимает любой объект-последовательность (строка, набор байтов, список, кортеж) или объект-коллекцию (словарь, множество) 
и возвращает число элементов последовательности

===================================================================================================================================
Математические функции


abs() - Принимает целое число или число с плавающей точкой. Возвращает абсолютное значение числа (по модулю)

round() - Принимает число с плавающей точкой. Округляет число до ближайшего целого числа. 
Может принимать число знаков после запятой, до которых необходимо выполнить округление

divmod() - Принимает два числа, возвращает также два числа 
(частное и остаток от деления чисел)

pow() - Принимает два числа. Позволяет возвести первое число в указанную степень

max() - Принимает итерируемый объект и возвращает самый большой элемент

min() - Принимает итерируемый объект и возвращает наименьший элемент

sum() - Суммирует элементы последовательности

===================================================================================================================================
Функция range()

Отвечает за генерацию набора чисел в пределах указанного диапазона. Для этого можно использовать ещё один параметр — шаг.

print(list(range(7))) # целые числа в диапазоне [0, 7)
print(list(range(2, 8))) # целые числа в диапазоне [2, 8)
print(list(range(1, 9, 2))) # целые числа в диапазоне [1, 9) с шагом 2
print(list(range(1, -7, -2))) # целые числа в диапазоне [1, -7) с шагом -2
print(list(range(0))) # целые числа в диапазоне (0, 0)
print(list(range(1, 0))) # целые числа в диапазоне (1, 0)

Функция range() может использоваться в циклах:
Пример:

for el in range(4, 20, 4):
    res = el / 2
    print(f"Результат деления {el} на 2: {int(res)}")

===================================================================================================================================
global 

Оператор global позволяет определить глобальную область видимости для переменной, объявленной в рамках функции.

===================================================================================================================================
Нелокальная область видимости

Перевод переменной в область видимости объемлющей функции.

Пример:

def ext_func():
    my_var = 0
    def int_func():
        nonlocal my_var
        my_var += 1
        return my_var
    return int_func

func_obj = ext_func()
print(func_obj)
print(func_obj())
print(func_obj())
print(func_obj())

===================================================================================================================================
«Функции builtins»


abs() - Возвращает абсолютное значение числа (целого или с плавающей точкой) 
all() - Возвращает True, если все элементы итерируемого объекта — истинные
any() - Возвращает True, если какой-либо элемент итерируемого объекта равен True
ascii() - Возвращает строку, содержащую печатаемое представление объекта 
bin() - Преобразует целое число в двоичную строку с префиксом 0b
bool() - Возвращает логическое значение (True или False)
breakpoint() - Перемещает в отладчик 
bytearray() - Возвращает массив байтов
bytes() - Возвращает объект bytes, представляющий собой неизменяемый набор целых чисел в диапазоне от 0 до 256
callable() - Возвращает True, если аргумент функции поддерживает возможность вызова
chr() - Возвращает символ, соответствующий коду Unicode (целому числу)
classmethod() - Преобразует функцию в метод класса, а не только его экземпляра
compile() - Компилирует исходный код в объект кода, либо в объект абстрактного синтаксического дерева
complex() - Помогает преобразовать в комплексное число
delattr() - Удалить из объекта указанный атрибут 
dict() - Вызов конструктора, создающего словарь
dir() - Возвращает список имён, определённых в модуле
divmod() - Возвращает частное-остаток от деления чисел
enumerate() - Возвращает генератор пар счётчик-элемент для элементов указанного набора
eval() - Выполняет разбор и запуск указанного выражения
exec() - Выполняет переданный в функцию код
filter() - Выполняет фильтрацию элементов объекта
float() - Преобразует объект к числу с плавающей точкой
format() - Форматирование переданного объекта
frozenset() - Создание неизменяемого множества
getattr()  - Получить значение атрибута объекта
globals() - Получить словарь с глобальной таблицей символов модуля
hasattr() - Возвращает True, если объект содержит указанный атрибут
hash() - Получить хеш объекта
help() - Вызов встроенной справки
hex() - Возвращает целое число в виде строки в шестнадцатеричном формате
id() - Получить идентификатор объекта
input() - Запросить строковый пользовательский ввод
int() - Преобразовать объект в целочисленный формат
isinstance() - Возвращает True, если переданный объект является экземпляром указанного класса
issubclass() - Возвращает True, если указанный класс является подклассом другого класса
iter() - Получить объект итератора
len() - Получить количество элементов в объекте
list() - Создание объекта-списка
locals() - Получить текущую локальную таблицу символов в виде словаря
map() - Применить указанную функцию к каждому элементу коллекции
max() - Возвращает элемент с максимальным значением из набора
memoryview() - Возвращает объект — представление в памяти для переданного аргумента
min() - Возвращает элемент с наименьшим значением из набора
next() - Получить очередной элемент итератора
object() - Создать новый базовый класс
oct() - Возвращает заданное целое число в восьмеричном формате в виде строки
open() - Открыть файл и вернуть его объект
ord() - Вернуть числовой код символа
pow() - Возвести число в степень
print() - Отправить указанный объект текстовым потоком
property() - Вернуть свойство
range() - Определить диапазон с шагом (при необходимости)
repr() - Получить для переданного объекта формальное строковое представление
reversed() - Получить обратный итератор для переданного набора значений
round() - Получить число с плавающей точкой. Округлённое до нужного числа знаков после запятой
set() - Создать изменяемое множество
setattr() - Связать с объектом указанный атрибут
slice() - Выполнить срез в последовательности
sorted() - Вернуть список, состоящий из элементов объекта, поддерживающего итерирование
staticmethod() - Определить указанную функцию в качестве статичного метода
str() - Преобразовать объект к строковому типу
sum() - Выполнить суммирование элементов объекта и вернуть результат
super() - Вернуть объект-посредник, перенаправляющий вызовы методов родителю 
tuple() - Создать кортеж
type() - Определить тип объекта
vars() - Получить словарь из атрибута __dict__ объекта
zip() - Вернуть итератор для кортежей, где каждый i-й кортеж содержит i-й элемент каждой из коллекций



















